{
  "whyRelishWasWritten": {
    "title": "Why Relish Was Written",
    "author": "David Griffiths",
    "date": "2018-11-09 07:59",
    "preview": "*Test-Driven Development* (TDD) is a terrible name.\n\nThe problem is â€¦",
    "content": "\n\n*Test-Driven Development* (TDD) is a terrible name.\n\nThe problem is that *test-driven development* sounds like it's all\nabout testing code, when really it's about designing code. The fact\nthat you end up with a bunch of automated tests as a result is really\njust happy side-effect.\n\nA better name for TDD would be *Example-Driven Design*, but it's\nprobably far too late to change the name now, so for the rest of this\npost I'll keep calling it TDD.\n\nMost software houses really don't do TDD. Most probably do automated\ntesting, but the two things are really not the same. The defining\nfeature of test-driven development is that you write the tests before\nthe code, and yet this rarely happens. Why is this? I think there are\ntwo reasons.\n\nFirstly, some companies make writing tests a *compliance activity*.\nThere are two kinds of thing that you do in your working life: Stuff\nthat has value - you'll work pretty hard at that, because the harder\nyou work, the better it is; and compliance activities - you'll put in\njust enough effort to... comply. You'll fill out a timesheet. You'll\nwear a name badge. You'll write automated tests. No one cares if you\nwrote the tests to help create a lean design, just so long as you check\nthem in as a delivered product. Test coverage is a great tool for\ndiscovering untested code, but too often it's applied like a modern-day\nequivalent of Samuel Goldwyn measuring the length of screenwriters'\npencils, to make sure they were working hard enough.\n\nThe second reason people don't write tests first is that, gosh-darn it,\nsome tests are just plain *difficult* to write. This is particularly\ntrue for user interface tests.\n\nWhen you write user interface code, you probably create a nicely\nstructured tree of interlocking components:\n\n![React Tree](/images/react-tree.png)\n\nBut then this code is converted into an ugly, complex series of\nlower-level components, like HTML elements of Android layout code.\n\n![Testing Chaos](/images/testing_chaos.png)\n\nThe structure, if not completely lost, is at least well hidden. Add to\nthat the fact that modern apps are frequently asynchronous, and your\ntesting code has to interact with some complex, shape-shifting\nmesomorph. Is it any wonder that most developers would sooner write\n[unit tests for JavaScript\ncode](http://corgibytes.com/blog/2016/12/13/i-hate-angular-testing/)\nthan write automated UI tests?\n\nIt might be, quite literally, a Tower of [Babel](https://babeljs.io/).\n\nThe consequence of this is that user interface code typically has few\nautomated tests, and those that do exist are particularly hard to write\nbefore the implementation. They will probably also be flaky. They might\nwork in the morning, and fail in the afternoon.\n\nNow if you're not developing the UI test-first, you are less likely to\nwrite tests first in the rest of the application too. The user interface\nhas clear objectives; it does things that are important to the customer,\nlike buying shoes or recording time; the kind of things mentioned in a\nuser story. But the code that underpins the user interface is more\nabstract. It reads data from data stores and translates data types. The\nabstract and complex nature of generated or asynchronous front-end code\nmakes it less likely that developers will write code test-first for\nthose parts of the application.\n\n## Relish UI Component Testing\n\nThat's why, at Black Pepper, we've created a library to make writing\nUI tests faster and simpler. It's called\n[Relish](https://github.com/BlackPepperSoftware/relish), and its aim is\nto give your tests a simpler view of the user interface that more\nclosely resembles the component-tree model that you create in the\nimplementation code:\n\n![Relish Tests](/images/relish_tests.png)\n\n*Relish* allows you to create testing components that shadow the actual\ncomponents in your application. When you tell a component to do\nsomething, it will handle the details of finding the right bit of HTML\nor Android layout code to talk to.\n\nYou can create composite *Relish* components by plugging together other\n*Relish* components. The library will automatically only look for\nsub-components that appear within their parent components. That reduces\nthe need for complex CSS selectors, XPath expressions, or Espresso view\ninteractions. *Relish* also plays nicely with BDD testing frameworks\nlike [Cucumber](https://cucumber.io/) so that you will write less glue\ncode to pass data from tests to the user-interface.\n\nBut this all sounds a little abstract. Let's do the right thing, and\ncreate an example.\n\n## The development cycle\n\nThis is a typical development cycle using *Relish*:\n\n![Devcycle](/images/devcycle.png)\n\nLet's say we're going to build a simple web-based task management\napplication. Rather than jump straight in with a complex series of UI\ndesigns and architecture, we'll work strictly through user stories.\n\n## 1. Create a user story\n\nThe first thing we need to do is create a user story. Here's an\nexample:\n\n    Feature: A list of tasks can be managed by the application\n    As a user\n    I want to be able to create, read, update and delete tasks\n    So that I can manage my time\n\nA user story has a standardised *As a... I want... So that...* format.\nThey are the basic materials used in an agile project to specify\nrequirements. They are typically numbered, so we'll make this *User\nStory \\#1*.\n\nThe user story here is written in [Gherkin format](https://github.com/cucumber/cucumber/wiki/Gherkin), which is a\nvery simple text-based format for specifying requirements. Gherkin files\ncan be executed by a library like [Cucumber JVM](https://github.com/cucumber/cucumber-jvm) as complete running\ntests. We'll store the user story in it's own Gherkin-formatted file\ncalled\n\n[0001-can-manage-list-of-tasks.feature](https://github.com/dogriffiths/relish/blob/master/examples/selenide/example-selenide/src/test/resources/features/0001-can-manage-list-of-tasks.feature).\n\nNow we need to create an example *scenario*, which describes a sequence\nof actions and expected results for the user story.\n\n## 2. Create a scenario (5 mins)\n\nWe'll begin with the simplest scenario: the case where we have no tasks\nrecorded:\n\n\n    Feature: A list of tasks can be managed by the application\n     As a user\n     I want to be able to create, read, update and delete tasks\n     So that I can manage my time\n    Scenario: Initially the list of tasks is empty\n     Given I am on the task list\n     Then the list of tasks will be empty\n\nThere will be multiple scenarios for each user story. Each scenario\nfollows a *Given... When... Then...* structure. The *Given..* part is\nthe setup required by the scenario, the *When...* describes some action\nthat that needs to be performed, and the *Then...* part is the expected\noutput. Here the scenario is so simple that there is no *When...* step;\nwe'll just open the application and check that no tasks are displayed.\n\n## 3. Sketch out the interface (5 mins)\n\nNow we can create a sketch of the user interface. At this point we need\na sketch that is purely functional. We don't care what it looks like,\nor how it's laid out. We just need something that tells us what\ninterface elements are required, with some notes about how they will be\nused.\n\n![Init All 2 1280X780](/images/init_all-2-1280x780.jpg)\n\nLater on, the detailed design of the interface can be developed as other\nstories are written. So long as the designs don't change this\nfunctional design, there should be few problems with UX designers\nworking in parallel with developers.\n\n## 4. Create the testing components (5 mins)\n\nSo far we've been describing a typical agile development sequence. Now\nfor the first time we come to the part where the *Relish* library will\nbe used.\n\nWe have a sketch of a page that will display all of the tasks, and we\nknow it will contain a table with the current list of tasks, and the\npage itself will have the URL /index.html.\n\nWe can create a *Relish* Page component for this:\n\n    public class TaskPage extends Page\n    {\n        public TaskPage()\n        {\n            super(\"/index.html\");\n        }\n        public Table taskTable()\n        {\n            return new Table(By.className(\\\"tasks\\\"), this);\n        }\n    }\n\nIt's a simple Java object that extends the *Relish* Page class. It\ncontains very little. In the constructor it specifies the path of the\npage, and we have a single method returning a *Relish* Table object,\nwhich we're going to assume will have the CSS class-name tasks.\n\nNotice that we provide no details beyond that. We're not even\nspecifying which columns are in the table.\n\nNow we've defined a testing object for the page, we can go ahead and\nwrite some test code that uses it.\n\n## 5. Write the Cucumber tests (10 mins)\n\nWe now need to write some *Cucumber* code that will turn this scenario:\n\n    Scenario: Initially the list of tasks is empty\n     Given I am on the task list\n     Then the list of tasks will be empty\n\nInto executable code. We'll this by writing come *glue* code that will\nsay exactly how to execute the lines in the scenario. This is the glue\ncode:\n\n    public class SomeSteps\n    {\n        private TaskPage taskPage = new TaskPage();\n        @Given(\"^I am on the task list$\")\n        public void iAmOnTheTaskList()\n        {\n            taskPage.launch();\n        }\n        @Then(\"^the list of tasks will be empty$\")\n        public void theListOfTasksWillBeEmpty()\n        {\n            taskPage.taskTable().assertEmpty();\n        }\n    }\n\nThere's one method for each step in the scenario. When *Cucumber* runs\nthe scenario, it will call `iAmOnTheTaskList()`, followed by\n`theListOfTasksWillBeEmpty()`. The first method will ask *Relish* to\nlaunch the Task page. The task page knows the URL of the page, so it\nwill automatically launch the browser at `/index.html` (NB: There are some\nother bits of configuration you will need to do when creating your\ntesting project, such as the network address of the application under\ntest, but we're not going to cover those here).\n\nThe second method will check that the task table is empty. It doesn't\ncare what columns appear in the table, because it doesn't need to know.\nThere's also no need to check for things like whether the page is\nloaded, or whether the table has appeared. This things are taken care of\nby *Relish*.\n\nThat brings us to the really important step....\n\n## 6. Implement the code (??? mins)\n\nHaving spent about 15 minutes creating the tests, you're now able to go\nand write the code. Chances are it will take longer to write the code\nthan it took to create the tests. But, you now have a better grasp on\nwhat's required. You know that you need a new page. You know what its\naddress will be. You know that you need to create a HTML table for the\ntasks with class name tasks.\n\nFor the purposes of this scenario, you should do the least amount of\nwork required to get the test running. That means you'll probably just\ncreate a hard-coded web page.\n\nHere's a screenshot of the page from the\n[tutorial](/#/tutorial/tutorial):\n\n![Frontpage](/images/frontpage.png)\n\nWe began with a completely trivial scenario, but it has forced us to\ncreate a working environment and publish a web page at the correct\naddress. We'll take things a little further by creating one more\nscenario.\n\n## Implementing a second scenario\n\nWe'll create a second Gherkin scenario at the end of our\n0001-can-manage-list-of-tasks.feature file:\n\n    ...\n    Scenario: I can add tasks\n    Given I am on the task list\n    When I choose to add these tasks\n      | Name            | Priority  | Status   |\n      | Buy some bread  | H         | ready    |\n      | Buy some milk   | L         | waiting  |\n    Then I will see this on the list of tasks\n      | Name            | Priority  | Status  |\n      | Buy some bread  | High      | Ready   |\n      | Buy some milk   | Low       | Waiting |\n\nWe'll need a lot more working code to implement this scenario, but how\nmuch more test code will we need?\n\nLet's begin as we did before, with a sketch of the user interface\nneeded. First, we'll add a button to the front page:\n\n![New All](/images/new_all.jpg)\n\nAnd we'll add a second page, containing a form where we can enter a new\ntask:\n\n![Add Task]('/images/add_task.jpg)\n\nNow we make sure we have the *Relish* components up to date. First,\nwe'll add a button to our TaskPage class:\n\n    public class TaskPage extends Page\n    {\n        public TaskPage()\n        {\n            super(\"/index.html\");\n        }\n        public Table taskTable()\n        {\n            return new Table(By.className(\"tasks\"), this);\n        }\n        public SelenideWidget addButton()\n        {\n            return new SelenideWidget(By.className(\"addButton\"), this);\n        }\n    }\n\nOur new addButton() returns a general SelenideWidget component, which is\nsomething that we can click.\n\nNext, we'll create a testing component for our *Add Task* page:\n\n    public class AddTaskPage extends Page {\n        public AddTaskPage() {\n            super(\"/add.html\");\n        }\n        public InputText name() {\n            return new InputText(By.id(\"name\"), this);\n        }\n        public DropDown priority() {\n            return new DropDown(By.id(\"priority\"), this);\n        }\n        public RadioButtons status() {\n            return new RadioButtons(By.name(\"status\"), this);\n        }\n        public SelenideWidget saveButton() {\n            return new SelenideWidget(By.className(\"saveButton\"), this);\n        }\n    }\n\nWe have one method for each of the components on the screen. This code\nis transcribed from the sketch. The only extra detail we've added is a\nset of CSS selectors where we'll expect to find the components on the\npage.\n\nOK, so the testing components only took a few minutes to write, but the\nglue code for the tests is likely to take far longer, right? After all\nthe scenario has a lot of detail about what needs to happen:\n\n    Scenario: I can add tasks\n      Given I am on the task list\n      When I choose to add these tasks\n      | Name           | Priority | Status  |\n      | Buy some bread | H        | ready   |\n      | Buy some milk  | L        | waiting |\n      Then I will see this on the list of tasks\n      | Name           | Priority | Status  |\n      | Buy some bread | High     | Ready   |\n      | Buy some milk  | Low      | Waiting |\n\nTo implement this scenario, we'll need these two step-methods in our\nglue-code:\n\n    ...\n    private AddTaskPage addTaskPage = new AddTaskPage();\n    ...\n        @When(\"^I choose to add these tasks$\")\n        public void iChooseToAddTheseTasks(List<TableRow> tasks) {\n            for(TableRow task : tasks) {\n                taskPage.addButton().click();\n                addTaskPage.set(task);\n                addTaskPage.saveButton().click();\n            }\n        }\n    @Then(\"^I will see this on the list of tasks$\")\n    public void iWillSeeThisOnTheListOfTasks(List<TableRow> tasks) {\n        taskPage.taskTable().matches(tasks);\n    }\n\nAll of the tabular information in the steps will be passed as lists of\n*Relish* TableRow objects. TableRow objects are designed to interact\nnicely with *Relish* testing components. For example, if we want to fill\nout the new task form with a row of data from the scenario, we do it\nwith a single line of code:\n\naddTaskPage.set(task);\n\n*Relish* will take this data:\n\n| Name           | Priority | Status |\n|----------------|----------|--------|\n| Buy some bread | H        | ready  |\n\nAnd update the components in the AddTaskPage class that match the\n*Name*, *Priority* and *Status* values. For the *Name* value, it will\nenter text into the text field, for *Priority* it will choose the value\nfrom a drop-down select list, and for *Status* it will click the\nmatching radio button.\n\nAnd for the list of tasks that we expect to find in the table:\n\n| Name           | Priority | Status  |\n|----------------|----------|---------|\n| Buy some bread | High     | Ready   |\n| Buy some milk  | Low      | Waiting |\n\nIt will check the entire table with a single line of code:\n\n    taskPage.taskTable().matches(tasks);\n\nNB: If you have a more complex table, containing interactive elements,\nyou get *Relish* to do that for you as well. See the\n[tutorial](/#/tutorial/tutorial-6)\nfor details.\n\nYou are now ready to implement the code for the scenario. How long would\nit take to write the tests? In the case of this second example, it might\ntake 15-30 mins. To implement the code? Probably a couple of hours.\n\n### **Summary**\n\nUI tests can be complex, but they don't need to be. You shouldn't\nwrite *all* of your tests at the UI level, in fact you probably\nshouldn't even write most of them. But unless you are able to write UI\ntests before you start the implementation, you are far less likely to do\ntest-driven development. *Relish* is still in the early stages of\ndevelopment, but we hope that you'll find it useful. Please give it a\ntry and send us feedback.\n",
    "iso8601Date": "2018-11-09T07:59:00+00:00",
    "basename": "whyRelishWasWritten"
  }
}
