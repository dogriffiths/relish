{
  "tutorial-1": {
    "title": "Creating the Project",
    "author": "David Griffiths",
    "image": "images/Relish.png",
    "date": "2018-11-09 07:59",
    "tags": [
      "Tutorial"
    ],
    "preview": "Relish is in the very early stages of development, so some of these …",
    "content": "\n\nRelish is in the very early stages of development, so some of these details are likely to change. You'll find all of the code for this worked example in the `examples/selenide/example-selenide` folder in the Git repo.\n\nWe're going to walk through the steps of creating a simple web application to manage and create tasks. The app itself is very simplistic and stores all of its data locally, but it will be complex enough to demonstrate how to use Relish with pretty much any web application.\n\nCreate a project for your test code. In a real application you would probably want to create this as some sort of checked-in module of the application itself. That way, the code and the tests can be committed together.\n\nWe will include a dependency to the Relish code, and we'll also add a few other test libraries that will allow us to use Relish with Cucumber. This is the `build.gradle` file we'll be using here:\n\n    apply plugin: 'java'\n    \n    sourceCompatibility = 1.8\n    \n    repositories {\n        mavenCentral()\n        maven { url 'https://jitpack.io' }\n    }\n    \n    dependencies {\n        testCompile group: 'junit', name: 'junit', version: '4.12'\n        testCompile group: 'info.cukes', name: 'cucumber-java', version: '1.2.5'\n        testCompile group: 'info.cukes', name: 'cucumber-junit', version: '1.2.5'\n        testCompile group: 'com.codeborne', name: 'selenide', version: '4.8'\n        testCompile group: 'org.hamcrest', name:'java-hamcrest', version: '2.0.0.0'\n        testCompile 'com.github.dogriffiths:relish:0.0.119' # For version 0.0.119\n    }\n\nThis will download the libraries from http://jitpack.io If you want to get the latest version of Relish, take a look at the [list of releases](https://github.com/dogriffiths/relish/releases).\n\nWe'll make the assumption that you'll have a file structure like this:\n\n    PROJECT_DIRECTORY +\n                      |\n                      +- build.gradle\n                      |\n                      +- src/\n                         |\n                         +- test/\n                         |  |\n                         |  +- java/\n                         |     |\n                         |     +- com/example/\n                         |        |\n                         |        +- <Java code goes here>\n                         |\n                         +- resources/\n                            |\n                            +- features/\n                               |\n                               +- <Cucumber feature tests go here>\n\n# Create a configuration class\n\nWe'll need to tell Cucumber about it's environment, and we'll do this with a class called `TestRunner`:\n\n    package com.example;\n    \n    import cucumber.api.CucumberOptions;\n    import cucumber.api.junit.Cucumber;\n    import org.junit.runner.RunWith;\n    \n    @RunWith(Cucumber.class)\n    @CucumberOptions(\n            features= \"classpath:features\",\n            glue={\"com.example.steps\"}\n    )\n    public class TestRunner {\n    }\n\n# Set up some hooks\n\n*Hooks* are part of the glue that allows Cucumber to work. They can before and after each test scenario, and they are typically used to initialize the UI (for example, by saying how to use the web browser) and to clear up after a test has finished. This is the `Hooks.java` that we'll be using:\n\n    package com.example.steps;\n    \n    import com.codeborne.selenide.Configuration;\n    \n    import org.openqa.selenium.WebDriverException;\n    \n    import java.io.IOException;\n    \n    import cucumber.api.CucumberOptions;\n    import cucumber.api.java.After;\n    import cucumber.api.java.Before;\n    \n    import static com.codeborne.selenide.Selenide.clearBrowserCookies;\n    import static com.codeborne.selenide.Selenide.clearBrowserLocalStorage;\n    \n    @CucumberOptions(features = \"features\")\n    public class Hooks {\n        @Before\n        public void before() throws IOException {\n            Configuration.browser = \"chrome\";\n            String property = System.getProperty(\"selenide.baseUrl\");\n            if (property == null) {\n                Configuration.baseUrl = \"http://localhost:8000\";\n            }\n        }\n    \n        @After\n        public void after() throws IOException {\n            clearBrowserCookies();\n            try {\n                clearBrowserLocalStorage();\n            } catch(WebDriverException wde) {\n                System.err.println(\"Cannot clear local storage. Non browser test?\");\n            }\n        }\n    }\n\nThis just says that we're expecting our application to be running at `http://localhost:8000`, that we'll use Chrome for our tests, and that we'll clear out the cookies and cache at the end of the test. This is important for our trivial example app, because we'll storing all of the data it creates in cookies.\n\n# Create a steps-file\n\nSteps are the lines of code that tell Cucumber how to run your test. We're going to create a single steps-file called `SomeSteps.java`:\n\n    package com.example.steps;\n    \n    public class SomeSteps\n    {\n    }\n \n\n^ [Tutorial](/#/tutorial/tutorial) | [Create our tests](/#/tutorial/tutorial-2) &gt;\n",
    "iso8601Date": "2018-11-09T07:59:00+00:00",
    "basename": "tutorial-1"
  }
,
  "tutorial-2": {
    "title": "Create Our Tests",
    "author": "David Griffiths",
    "image": "images/Relish.png",
    "date": "2018-11-09 07:59",
    "tags": [
      "Tutorial"
    ],
    "preview": "We're going to create an application that will allow a user to …",
    "content": "\n\n\nWe're going to create an application that will allow a user to create, read, update and delete tasks. Let's say this is our first user story:\n\n> **Story 1: A list of tasks can be managed by the application**\n> \n> As a user\n> \n> I want to be able to create, read, update and delete tasks\n> \n> So that I can manage my time\n\nWe'll create a new Cucumber `feature` file in the `src/resources/features/` folder called `0001-can-manage-list-of-tasks.feature`\n\n    Feature: A list of tasks can be managed by the application\n      As a user\n      I want to be able to create, read, update and delete tasks\n      So that I can manage my time\n\nNow we'll add our first scenario&#x2013;a test that checks that when the app is first started, that there are no tasks recorded. When we write the application, we'll expect the main page to look something like this:\n\n![img](images/notasks.png)\n\nWe can write a scenario to check that this is true:\n\n    Feature: A list of tasks can be managed by the application\n      As a user\n      I want to be able to create, read, update and delete tasks\n      So that I can manage my time\n    \n      Scenario: Initially the list of tasks is empty\n        Given I am on the task list\n        Then the list of tasks will be empty\n\nThis scenario contains two steps:\n\n* Launch the app on the task list page\n* Check that the table of lists is empty\n\nWe'll need to write methods for each of these in the `SomeSteps.java` file that will automate the application for us.\n\nAnd this is where Relish finally makes an appearance&#x2026;\n\n&lt; [Creating the project](/#/tutorial/tutorial-1) | ^ [Tutorial](/#/tutorial/tutorial) | [Relish components](/#/tutorial/tutorial-3) &gt;\n",
    "iso8601Date": "2018-11-09T07:59:00+00:00",
    "basename": "tutorial-2"
  }
,
  "tutorial-3": {
    "title": "Relish Components",
    "author": "David Griffiths",
    "image": "images/Relish.png",
    "date": "2018-11-09 07:59",
    "tags": [
      "Tutorial"
    ],
    "preview": "What we *could* do at this point, is write a couple of methods that …",
    "content": "\n\nWhat we *could* do at this point, is write a couple of methods that will use Selenide or Selenium code to automate the browser. And the code to launch the app and go to the task list page, then check that a table is empty probably won't be that long. But the trouble is that we are likely to interact with the same components and pages multiple times as we create more and more scenarios.\n\nAnd that's where Relish helps. Relish allows you to quickly build testing components that represent the various elements of your UI, and allows you to interact with them in a simpler and more re-usable way.\n\n## Launching the front page\n\nLet's begin with the first step: 'Given I am on the task list'. We'll create a Relish *Page* class that represents the main page of our app:\n\n    package com.example.components;\n    \n    import uk.co.blackpepper.relish.selenide.Page;\n    \n    public class TaskPage extends Page\n    {\n        public TaskPage()\n        {\n            super(\"/index.html\");\n        }\n    }\n\nThis `TaskPage` is a testing facade that represents the front page of our application. Any kind of interaction we make with the `index.html` page, we'll make through this object. We'll need to construct a `TaskPage` object in our `SomeSteps.java` file, which we can then use in the 'Given I am on the task list' step:\n\n    package com.example.steps;\n    \n    import com.example.components.TaskPage;\n    \n    import cucumber.api.java.en.Given;\n    \n    public class SomeSteps\n    {\n        private TaskPage taskPage = new TaskPage();\n    \n        @Given(\"^I am on the task list$\")\n        public void iAmOnTheTaskList()\n        {\n            taskPage.launch();\n        }\n    }\n\nBecause the `TaskPage` extends the Relish `Page` class, it automatically knows how to contact the web driver and launch the correct URL.\n\n## Checking that the table is empty\n\nNow we need to check that the table on the front page is empty. Again, we could just write some Selenide code in the step method in `SomeSteps`, but instead we will simply tell the `TaskPage` that it will contain a table for the tasks:\n\n    package com.example.components;\n    \n    import org.openqa.selenium.By;\n    \n    import uk.co.blackpepper.relish.selenide.Table;\n    import uk.co.blackpepper.relish.selenide.Page;\n    \n    public class TaskPage extends Page\n    {\n        public TaskPage()\n        {\n            super(\"/index.html\");\n        }\n    \n        public Table taskTable()\n        {\n            return new Table(By.className(\"tasks\"), this);\n        }\n    }\n\nThe `taskTable()` method of the page returns a Relish object that represents the `Table` object that will be on the front screen. When we construct Relish web components, we need to provide two pieces of information:\n\n\nNow that we have a `taskTable()` for our page, how do we use it? Let's add the implementation for our second step:\n\n    package com.example.steps;\n    \n    import com.example.components.TaskPage;\n    \n    import cucumber.api.java.en.Given;\n    import cucumber.api.java.en.Then;\n    \n    public class SomeSteps\n    {\n        private TaskPage taskPage = new TaskPage();\n    \n        @Given(\"^I am on the task list$\")\n        public void iAmOnTheTaskList()\n        {\n            taskPage.launch();\n        }\n    \n        @Then(\"^the list of tasks will be empty$\")\n        public void theListOfTasksWillBeEmpty()\n        {\n            taskPage.taskTable().assertEmpty();\n        }\n    }\n\nThe `Table` object will look at the number of rows in the table that contain actual data (<td> cells) and checks that none are visible.\n\nAnd that's it for our first scenario. Relish hides away a lot of the details of the low-level interaction with the browser. Most the application-specific test code we've written has been in the `TaskPage` class, defining the expected functional structure of the page. \n\nNow we've spent a few minutes creating this test, we can go an implement the initial web page.\n\n![img](images/notasks.png)\n\n&lt; [Creating our tests](/#/tutorial/tutorial-2) | ^ [Tutorial](/#/tutorial/tutorial) | [Adding tasks](/#/tutorial/tutorial-4) &gt;\n",
    "iso8601Date": "2018-11-09T07:59:00+00:00",
    "basename": "tutorial-3"
  }
,
  "tutorial-4": {
    "title": "Adding Tasks",
    "author": "David Griffiths",
    "image": "images/Relish.png",
    "date": "2018-11-09 07:59",
    "tags": [
      "Tutorial"
    ],
    "preview": "Our first scenario was obviously very simplistic. Now let's create a …",
    "content": "\n\nOur first scenario was obviously very simplistic. Now let's create a second, which requires a little more interactivity:\n\n    Scenario: I can add a task\n      Given I am on the task list\n      When I choose to add these tasks\n        | Name           |\n        | Buy some bread |\n        | Buy some milk  |\n      Then I will see this on the list of tasks\n        | Name           |\n        | Buy some bread |\n        | Buy some milk  |\n\nHere we're using Cucumber feature-tables to specify the details of the tasks we going to add, and expect to the see on the application. Our scenario will begin by launching the app in the same way, but then will create a list of tasks, and check that they all appear on the front page as expected. \n\nWe'll create each task with a second page containing a form that will allow us to enter the details of the task. When we save that task we'll return back to the front page of the application, where we should see our new task listed.\n\n![img](images/add-design.png)\n\nSo we'll a button on the front page for adding a task:\n\n![img](images/addtaskbutton.png)\n\nAnd we'll need a second page with a simple form for entering a task, with a \"Save\" button:\n\n![img](images/addformpage.png)\n\nWhen we click on the 'Add task' button on the front page, it will launch the 'Add task page', where we can fill out the details for the task, click 'Save' and return to the front page, where our new task will appear.\n\n## Implementing the 'When I choose to add these tasks' step\n\nWe'll first modify our `TaskPage` class, adding in a testing component for the 'Add task' button:\n\n    package com.example.components;\n    \n    import org.openqa.selenium.By;\n    \n    import uk.co.blackpepper.relish.selenide.Table;\n    import uk.co.blackpepper.relish.selenide.Page;\n    import uk.co.blackpepper.relish.selenide.SelenideWidget;\n    \n    public class TaskPage extends Page\n    {\n        public TaskPage()\n        {\n            super(\"/index.html\");\n        }\n    \n        public Table taskTable()\n        {\n            return new Table(By.className(\"tasks\"), this);\n        }\n    \n        public SelenideWidget addButton()\n        {\n            return new SelenideWidget(By.className(\"addButton\"), this);\n        }\n    }\n\nOur new `addButton()` method returns `SelenideWidget` Relish object. This is a generic component that represent some part of a web page that we can look at and click. \n\nWe'll also need to create a class for our second page: the one for creating a new task. We'll this `AddTaskPage`:\n\n    package com.example.components;\n    \n    import uk.co.blackpepper.relish.selenide.InputText;\n    import uk.co.blackpepper.relish.selenide.Page;\n    import uk.co.blackpepper.relish.selenide.SelenideWidget;\n    import org.openqa.selenium.By;\n    \n    public class AddTaskPage extends Page {\n        public AddTaskPage() {\n            super(\"/add.html\");\n        }\n    \n        public InputText name() {\n            return new InputText(By.id(\"name\"), this);\n        }\n    \n        public SelenideWidget saveButton() {\n            return new SelenideWidget(By.className(\"saveButton\"), this);\n        }\n    }\n\nThis class will be used to interact with the 'Add task page', which it will expect to find at path `/add.html`. It will include a button with the class name \"saveButton\" (which we represent by a `SelenideWidget` object), and also an `InputText` component with id \"name\". `InputText` is another Relish component for interacting with text fields.\n\nNow we that have our page objects structured in the way that we want, we now need to write a 'When I choose to add these tasks' step. Remember: this is what the step looks like in our scenario:\n\n    When I choose to add these tasks\n      | Name           |\n      | Buy some bread |\n      | Buy some milk  |\n\nThis step will need to be passed the contents of the data-table containing the details of our new tasks. We normally do this in a Relish test by specifying the table as a list of Relish `TableRow` objects:\n\n    @When(\"^I choose to add these tasks$\")\n    public void iChooseToAddTheseTasks(List<TableRow> tasks)\n    {\n    ....\n    }\n\nA `TableRow` is very similar to a `Map<String,String>` and it's designed specifically to interact with Relish components. You'll see how shortly.\n\nNow that we've begun to create our step, we'll need to fill out the code. We'll loop through each of the `TableRow` objects from the table, and for each one:\n\n1. Click on the /Add Task/ button\n2. Enter details into the /Add New Task/ form that match the =TableRow=\n3. Click the /Save/ button on the form and return to the front page\n\nThis is how this is done in Relish:\n\n    @When(\"^I choose to add these tasks$\")\n    public void iChooseToAddTheseTasks(List<TableRow> tasks)\n    {\n        for(TableRow task : tasks)\n        {\n            taskPage.addButton().click();\n            addTaskPage.set(task);\n            addTaskPage.saveButton().click();\n        }\n    }\n\nNotice that we're assuming here we've created a `addTaskPage` object higher up in the class.\n\nThe `addButton()` and `saveButton()` components (like all `selenide-relish` widgets) have `click()` methods. The interesting line is `addTaskPage.set(task)`.\n\nThe `set()` method accepts a `TableRow` object and uses it to update all of the sub-components whose names match the columns in the `TableRow`. So because our table looks like this:\n\n<table border=\"2\" cellspacing=\"0\" cellpadding=\"6\" rules=\"groups\" frame=\"hsides\">\n\n\n<colgroup>\n<col  class=\"left\" />\n</colgroup>\n<thead>\n<tr>\n<th scope=\"col\" class=\"left\">Name</th>\n</tr>\n</thead>\n\n<tbody>\n<tr>\n<td class=\"left\">Buy some bread</td>\n</tr>\n\n\n<tr>\n<td class=\"left\">Buy some milk</td>\n</tr>\n</tbody>\n</table>\n\nThe `set()` method will convert the (only) column \"Name\" into camel-case, and look for a `name()` method on the `AddTaskPage` object. In our case, this `name()` method returns an `InputText` field, and Relish will tell the `InputText` component to type in the strings \"Buy some bread\" and \"Buy some milk\" on each of the occasions that it visits the page.\n\nIf there had been multiple columns in the feature table, Relish would have looked for a matching component for each of them, and entered the data into each of the fields in the form.\n\nThis is where we start to benefit from the testing components built in to Relish: a lot of the boring \"glue\" code that takes data from a Cucumber scenario and passes it through to Selenide is done for us.\n\n## Implementing the 'Then I will see this on the list of tasks' step\n\nNow we need to check that the tasks we entered in the previous step now appear on the list of tasks on the main screen:\n\n    Then I will see this on the list of tasks\n      | Name           |\n      | Buy some bread |\n      | Buy some milk  |\n\nThis is actually remarkably easy to implement, because we already have all the components in place in the `Page` objects:\n\n    @Then(\"^I will see this on the list of tasks$\")\n    public void iWillSeeThisOnTheListOfTasks(List<TableRow> tasks)\n    {\n        taskPage.taskTable().matches(tasks);\n    }\n\nThis uses the `matches()` method of the `taskTable()` to assert that the table contains rows that match the detail of each `TableRow`. The `Table` object will handle all of the details of finding the column headings and matching them to the column names in the table. \n\nThat completes the scenario. This is the current state of our `SomeSteps` class:\n\n    package com.example.steps;\n    \n    import com.example.components.AddTaskPage;\n    import com.example.components.TaskPage;\n    \n    import uk.co.blackpepper.relish.core.TableRow;\n    \n    import java.util.List;\n    \n    import cucumber.api.java.en.Given;\n    import cucumber.api.java.en.Then;\n    import cucumber.api.java.en.When;\n    \n    public class SomeSteps\n    {\n        private TaskPage taskPage = new TaskPage();\n        private AddTaskPage addTaskPage = new AddTaskPage();\n    \n        @Given(\"^I am on the task list$\")\n        public void iAmOnTheTaskList()\n        {\n            taskPage.launch();\n        }\n    \n        @Then(\"^the list of tasks will be empty$\")\n        public void theListOfTasksWillBeEmpty()\n        {\n            taskPage.taskTable().assertEmpty();\n        }\n    \n        @When(\"^I choose to add these tasks$\")\n        public void iChooseToAddTheseTasks(List<TableRow> tasks)\n        {\n            for(TableRow task : tasks)\n            {\n                taskPage.addButton().click();\n                addTaskPage.set(task);\n                addTaskPage.saveButton().click();\n            }\n        }\n    \n        @Then(\"^I will see this on the list of tasks$\")\n        public void iWillSeeThisOnTheListOfTasks(List<TableRow> tasks)\n        {\n            taskPage.taskTable().matches(tasks);\n        }\n    }\n\n&lt; [Relish components](/#/tutorial/tutorial-3) | ^ [Tutorial](/#/tutorial/tutorial) | [Adding more fields](/#/tutorial/tutorial-5) &gt;\n",
    "iso8601Date": "2018-11-09T07:59:00+00:00",
    "basename": "tutorial-4"
  }
,
  "tutorial-5": {
    "title": "Adding more fields",
    "author": "David Griffiths",
    "image": "images/Relish.png",
    "date": "2018-11-09 07:59",
    "tags": [
      "Tutorial"
    ],
    "preview": "Now let's see what happens if there's a sudden change or …",
    "content": "\n\nNow let's see what happens if there's a sudden change or requirements. Let's say that the customer suddenly decides that instead of just recording the *name* against each task, we also want to record a *priority* value of `H` (*High*), `M` (*Medium*) or `L` (*Low*).\n\n![img](images/tasks-with-priorities.png)\n\n![img](images/add-with-priority.png)\n\nLet's look at what kind of impact that has on our tests. First, let's edit the feature file to include the new *Priority* field:\n\n    Scenario: I can add a task\n      Given I am on the task list\n      When I choose to add these tasks\n        | Name           | Priority |\n        | Buy some bread | H        |\n        | Buy some milk  | L        |\n      Then I will see this on the list of tasks\n        | Name           | Priority |\n        | Buy some bread | High     |\n        | Buy some milk  | Low      |\n\n*Note*: when we *add* tasks we are specifying the value (*H*, *M* or *L*) but when we check what we want on the screen, we using the descriptions (*High*, *Medium* or *Low*). That's because we're going to send the *values* to the dropdown list on the screen, but the *descriptions* will appear in the table of tasks. Relish will usually cope with descriptions on `<select/>` fields, but it's better to specify values in your tests if they are going to be used to update `<select/>` fields or radio buttons.\n\nWhat do we need to do to handle the new *Priority* value? We will begin by adding a new field to the `AddTaskPage` class:\n\n    package com.example.components;\n\n    import org.openqa.selenium.By;\n    \n    import uk.co.blackpepper.relish.selenide.DropDown;\n    import uk.co.blackpepper.relish.selenide.InputText;\n    import uk.co.blackpepper.relish.selenide.Page;\n    import uk.co.blackpepper.relish.selenide.SelenideWidget;\n    \n    public class AddTaskPage extends Page {\n        public AddTaskPage() {\n            super(\"/add.html\");\n        }\n    \n        public InputText name() {\n            return new InputText(By.id(\"name\"), this);\n        }\n    \n        public DropDown priority() {\n            return new DropDown(By.id(\"priority\"), this);\n        }\n    \n        public SelenideWidget saveButton() {\n            return new SelenideWidget(By.className(\"saveButton\"), this);\n        }\n    }\n\nThe field we've added is a Relish `DropDown` widget, which is used to interact with HTML `<select/>` elements.\n\nWhat else do we need to do? Well actually, **nothing**. Let's review the updated scenario:\n\n    Scenario: I can add a task\n      Given I am on the task list\n      When I choose to add these tasks\n        | Name           | Priority |\n        | Buy some bread | H        |\n        | Buy some milk  | L        |\n      Then I will see this on the list of tasks\n        | Name           | Priority |\n        | Buy some bread | High     |\n        | Buy some milk  | Low      |\n\nWe already have a step to add tasks:\n\n    @When(\"^I choose to add these tasks$\")\n    public void iChooseToAddTheseTasks(List<TableRow> tasks)\n    {\n        for(TableRow task : tasks)\n        {\n            taskPage.addButton().click();\n            addTaskPage.set(task);\n            addTaskPage.saveButton().click();\n        }\n    }\n\nThis code passes the contents of the feature table straight to the `AddTaskPage`. Relish will match the new *Priority* column with the `DropDown` widget returned from the `AddTaskPage.priority()` method, and pass it the *H*, *M* and *L* values to it.\n\nWe've also already implemented the step to check the list of all tasks:\n\n    @Then(\"^I will see this on the list of tasks$\")\n    public void iWillSeeThisOnTheListOfTasks(List<TableRow> tasks)\n    {\n        taskPage.taskTable().matches(tasks);\n    }\n\nThis passes the feature table to the `Table` object, which will automatically checks that the new column appears in the table.\n\nThis demonstrates how Relish can help you not only create UI tests more quickly, but it can also greatly reduce the impact of changes to your tests.\n\n&lt; [Adding tasks](/#/tutorial/tutorial-4) | ^ [Tutorial](/#/tutorial/tutorial) | [Deleting tasks](/#/tutorial/tutorial-6) &gt;\n",
    "iso8601Date": "2018-11-09T07:59:00+00:00",
    "basename": "tutorial-5"
  }
,
  "tutorial-6": {
    "title": "Deleting Tasks",
    "author": "David Griffiths",
    "image": "images/Relish.png",
    "date": "2018-11-09 07:59",
    "tags": [
      "Tutorial"
    ],
    "preview": "For our third scenario, we'll create a test that checks we can …",
    "content": "\n\nFor our third scenario, we'll create a test that checks we can delete tasks. To do this, we'll allow the user to select a set of existing tasks, and then delete them:\n\n![img](images/delete-tasks.png)\n\n    Scenario: Can delete tasks\n      Given I am on the task list\n      Then the delete button is disabled\n      When I choose to add these tasks\n        | Name           | Priority |\n        | Buy some bread | H        |\n        | Buy some milk  | M        |\n        | Buy some water | L        |\n      And I will select these tasks\n        | Name           | Priority | Select |\n        | Buy some bread | High     | true   |\n        | Buy some milk  | Medium   | false  |\n        | Buy some water | Low      | true   |\n      And I choose to delete the selected tasks\n      Then I will see this on the list of tasks\n        | Name          | Priority | Select |\n        | Buy some milk | Medium   | false  |\n\n## Add a delete button and checkboxes to the page\n\nIt should be obvious what the first thing we need to do is: add the components to the `TaskPage` object. We'll need a delete button:\n\n    package com.example.components;\n    \n    import org.openqa.selenium.By;\n    \n    import uk.co.blackpepper.relish.selenide.Table;\n    import uk.co.blackpepper.relish.selenide.Page;\n    import uk.co.blackpepper.relish.selenide.SelenideWidget;\n    \n    public class TaskPage extends Page\n    {\n        public TaskPage()\n        {\n            super(\"/index.html\");\n        }\n    \n        public Table taskTable()\n        {\n            return new Table(By.className(\"tasks\"), this);\n        }\n    \n        public SelenideWidget addButton()\n        {\n            return new SelenideWidget(By.className(\"addButton\"), this);\n        }\n    \n        public SelenideWidget deleteButton()\n        {\n            return new SelenideWidget(By.className(\"deleteButton\"), this);\n        }\n    }\n\nBut then there's something a little more complex that we need to do: to modify the `Table` object returned from `taskTable()` so that it has the ability to interact with the checkbox in the `Selected` column of each table row.\n\nBy default, each cell in a `Table` is a simple `SelenideWidget`. That means the table is able to look at the text inside the table-cell, but it can't treat it like a more complex component, like a checkbox.\n\nTo do that, we need to call the `withCellComponent(...)` method of the `Table` object. This allows us to construct a Relish component for any given column:\n\n    package com.example.components;\n    \n    import org.openqa.selenium.By;\n    \n    import uk.co.blackpepper.relish.selenide.Checkbox;\n    import uk.co.blackpepper.relish.selenide.Table;\n    import uk.co.blackpepper.relish.selenide.Page;\n    \n    public class TaskPage extends Page\n    {\n        public TaskPage()\n        {\n            super(\"/index.html\");\n        }\n    \n        public Table taskTable()\n        {\n            return new Table(By.className(\"tasks\"), this)\n                .withCellComponent(\"select\", (tdCell) -> new Checkbox(tdCell.$(\"input\"), this))\n                ;\n        }\n    \n        public SelenideWidget addButton()\n        {\n            return new SelenideWidget(By.className(\"addButton\"), this);\n        }\n    \n        public SelenideWidget deleteButton()\n        {\n            return new SelenideWidget(By.className(\"deleteButton\"), this);\n        }\n    }\n\nThe `.withCellComponent(...)` line will automatically generate a `Checkbox` component for testing the checkbox `input` element in the `select` column.\n\n## Implement the \"delete tasks\" steps\n\nLet's take another look at our new scenario:\n\n    Scenario: Can delete tasks\n      Given I am on the task list\n      Then the delete button is disabled\n      When I choose to add these tasks\n        | Name           | Priority |\n        | Buy some bread | H        |\n        | Buy some milk  | M        |\n        | Buy some water | L        |\n      And I will select these tasks\n        | Name           | Priority | Select |\n        | Buy some bread | High     | true   |\n        | Buy some milk  | Medium   | false  |\n        | Buy some water | Low      | true   |\n      And I choose to delete the selected tasks\n      Then I will see this on the list of tasks\n        | Name          | Priority | Select |\n        | Buy some milk | Medium   | false  |\n\nWe have already implemented a `Given I am on the task list` step. \n\nThe code for the `Then the delete button is disabled` can call our new `deleteButton()` component:\n\n    @Then(\"^the delete button is disabled$\")\n    public void theDeleteButtonIsDisabled()\n    {\n        taskPage.deleteButton().assertDisabled();\n    }\n\nThe `assertDisabled()` method will check that the button is disabled.\n\nWe have already implemented the `When I choose to add these tasks` step.\n\nBut we will need to write new code for `And I will select these tasks`. This step will need to interact with the `Checkbox` objects we just added to the `taskTable()` object.\n\nOur step will use this data from the feature file:\n\n| Name           | Priority | Select |\n|----------------|----------|--------|\n| Buy some bread | High     | true   |\n| Buy some milk  | Medium   | false  |\n| Buy some water | Low      | true   |\n\nThere's something we need to think about before we implement this step: we need to update the checkboxes using the data in the `Select` column, but we **can't** update the data in the `Name` or `Priority` columns, because they contain static text:\n\n![img](images/delete-tasks.png)\n\nSo what we'll do instead is get the step to split the table into two tables that are like this:\n\n| Name           | Priority |\n|----------------|----------|\n| Buy some bread | High     |\n| Buy some milk  | Medium   |\n| Buy some water | Low      |\n\nand\n\n| Select |\n|--------|\n| true   |\n| false  |\n| true   |\n\nWe'll use the data in the first table to check that the rows on the screen *match* the data in the table, then we'll use the data in the second table to *set* the checkboxes in the table.\n\nHow do we split the tables? Fortunately, the `TableRow` object has the ability to create new versions of itself, with some columns removed. For example, if a `TableRow` object called `row` has columns `height`, `weight`, `age` and `gender`, we can create a new `TableRow` object with `weight` and `gender` columns with `row.except(\"weight\", \"gender\")`.\n\nSo if our origin feature table is called `tasks`, we can create a table just without the `Select` column with:\n\n    tasks.stream().map(t -> t.except(\"select\")).collect(Collectors.toList())\n\nAnd a table without the `Name` and `Priority` columns with:\n\n    tasks.stream().map(t -> t.except(\"name\", \"priority\")).collect(Collectors.toList())\n\nWe can then pass these two tables (or, rather, these lists of `TableRows`) to the components like this:\n\n    @When(\"^I will select these tasks$\")\n    public void iWillSelectTheseTasks(List<TableRow> tasks)\n    {\n        taskPage.taskTable().matches(tasks.stream().map(t -> t.except(\"select\")).collect(Collectors.toList()));\n        taskPage.taskTable().set(tasks.stream().map(t -> t.except(\"name\", \"priority\")).collect(Collectors.toList()));\n    }\n\nThat way our step will *check* that the `name` cells match the data in our feature file, and it will *set* the checkboxes according the `true` / `false` values given in the same table.\n\nFinally, to implement the `And I choose to delete the selected tasks` step, we can simply call the `click()` method on the `tasksPage.deleteButton()` method.\n\nThat means our `SomeSteps.java` file currently looks like this:\n\n    package com.example.steps;\n    \n    import com.example.components.AddTaskPage;\n    import com.example.components.TaskPage;\n    \n    import uk.co.blackpepper.relish.core.TableRow;\n    \n    import java.util.ArrayList;\n    import java.util.List;\n    import java.util.stream.Collectors;\n    \n    import cucumber.api.java.en.Given;\n    import cucumber.api.java.en.Then;\n    import cucumber.api.java.en.When;\n    \n    public class SomeSteps\n    {\n        private TaskPage taskPage = new TaskPage();\n        private AddTaskPage addTaskPage = new AddTaskPage();\n    \n        @Given(\"^I am on the task list$\")\n        public void iAmOnTheTaskList()\n        {\n            taskPage.launch();\n        }\n    \n        @Then(\"^the list of tasks will be empty$\")\n        public void theListOfTasksWillBeEmpty()\n        {\n            taskPage.taskTable().assertEmpty();\n        }\n    \n        @When(\"^I choose to add these tasks$\")\n        public void iChooseToAddTheseTasks(List<TableRow> tasks)\n        {\n            for(TableRow task : tasks)\n            {\n                taskPage.addButton().click();\n                addTaskPage.set(task);\n                addTaskPage.saveButton().click();\n            }\n        }\n    \n        @Then(\"^I will see this on the list of tasks$\")\n        public void iWillSeeThisOnTheListOfTasks(List<TableRow> tasks)\n        {\n            taskPage.taskTable().matches(tasks);\n        }\n    \n        @When(\"^I will select these tasks$\")\n        public void iWillSelectTheseTasks(List<TableRow> tasks)\n        {\n            taskPage.taskTable().matches(tasks.stream().map(t -> t.except(\"select\")).collect(Collectors.toList()));\n            taskPage.taskTable().set(tasks.stream().map(t -> t.except(\"name\", \"priority\")).collect(Collectors.toList()));\n        }\n    \n        @When(\"^I choose to delete the selected tasks$\")\n        public void iChooseToDeleteTheSelectedTasks()\n        {\n            taskPage.deleteButton().click();\n        }\n    \n        @Then(\"^the delete button is disabled$\")\n        public void theDeleteButtonIsDisabled()\n        {\n            taskPage.deleteButton().assertDisabled();\n        }\n    }\n\n&lt; [Adding more fields](/#/tutorial/tutorial-5) | ^ [Tutorial](/#/tutorial/tutorial) | [Editing tasks](/#/tutorial/tutorial-7) &gt;\n",
    "iso8601Date": "2018-11-09T07:59:00+00:00",
    "basename": "tutorial-6"
  }
,
  "tutorial-7": {
    "title": "Editing Tasks",
    "author": "David Griffiths",
    "image": "images/Relish.png",
    "date": "2018-11-09 07:59",
    "tags": [
      "Tutorial"
    ],
    "preview": "&lt; [Deleting tasks](./tutorial-6.html) | ^ …",
    "content": "\n\n&lt; [Deleting tasks](./tutorial-6.html) | ^ [Tutorial](./tutorial.html) | [Custom components](./tutorial-8.html) &gt;\n\nWhich brings us to the final scenario for this feature: editing tasks\n\n    Scenario: Can edit a task\n      Given I am on the task list\n      When I choose to add these tasks\n        | Name           | Priority |\n        | Buy some bread | M        |\n        | Buy some milk  | L        |\n        | Buy some water | H        |\n      And I edit the 'Buy some milk' task\n      Then the edit form will contain\n        | Name     | Buy some milk |\n        | Priority | L             |\n      When I save these changes\n        | Name     | Buy some cream |\n        | Priority | M              |\n      Then I will see this on the list of tasks\n        | Name           | Priority |\n        | Buy some bread | Medium   |\n        | Buy some cream | Medium   |\n        | Buy some water | High     |\n\nWe'll need a new page for editing tasks. It will be virtually identical to to the `AddTaskPage`:\n\n![img](images/edit-task.png)\n\n    package com.example.components;\n    \n    import org.openqa.selenium.By;\n    \n    import uk.co.blackpepper.relish.selenide.DropDown;\n    import uk.co.blackpepper.relish.selenide.InputText;\n    import uk.co.blackpepper.relish.selenide.Page;\n    import uk.co.blackpepper.relish.selenide.SelenideWidget;\n    \n    public class EditTaskPage extends Page {\n        public EditTaskPage() {\n            super(\"/edit.html\");\n        }\n    \n        public InputText name() {\n            return new InputText(By.id(\"name\"), this);\n        }\n    \n        public DropDown priority() {\n            return new DropDown(By.id(\"priority\"), this);\n        }\n    \n        public SelenideWidget saveButton() {\n            return new SelenideWidget(By.className(\"saveButton\"), this);\n        }\n    }\n\nBut this is the design for the \"Edit\" button on the front screen:\n\n![img](images/edit-button-on-list.png)\n\nIn this design, the column containing the \"Edit\" buttons does not have a heading. How do we refer to that column?\n\nBy default, a column without a heading if given a virtual heading that matches the number of the column, starting at zero. That means we can update the `taskTable()` to be aware of the \"Edit\" button like this:\n\n    public Table taskTable()\n    {\n        return new Table(By.className(\"tasks\"), this)\n            .withCellComponent(\"select\", (tdCell) -> new Checkbox(tdCell.$(\"input\"), this))\n            .withCellComponent(\"3\", (tdCell) -> new SelenideWidget(tdCell.$(\"button\"), this))\n            ;\n    }\n\nWe'll need to implement these three steps:\n\n    And I edit the 'Buy some milk' task\n    Then the edit form will contain\n      | Name     | Buy some milk |\n      | Priority | L             |\n    When I save these changes\n      | Name     | Buy some cream |\n      | Priority | M              |\n\nTo implement the `I edit the.... task` step will need to get access to the `Edit` button of the table row with the correct name value. We can find the correct `Table` row by using a method called `findFirst(...)`, which uses an expression to find the first matching row:\n\n    taskPage.taskTable().findFirst(row -> row.get(\"name\").equals(\"Buy some milk\"))\n\nThis will return a Relish `HtmlRow` test component for the first row it finds with the correct name. The `HtmlRow` has a method called `getWidget(...)` which gives us access to the component for a single cell, either by passing a name, or a column number. That means we can click on the edit button for the `Buy some milk` row with this:\n\n    taskPage.taskTable().findFirst(row -> row.get(\"name\").equals(\"Buy some milk\")).getWidget(3).click();\n\nFor other two steps (`the edit form will contain...` and `I save these changes...`) we can just call the `match(...)`, `set(...)` and `click()` methods we've already seen.\n\nAdding all three steps, brings us to this version of the `SomeSteps.java` file:\n\n    package com.example.steps;\n    \n    import com.example.components.AddTaskPage;\n    import com.example.components.EditTaskPage;\n    import com.example.components.TaskPage;\n    \n    import uk.co.blackpepper.relish.core.TableRow;\n    \n    import java.util.List;\n    import java.util.stream.Collectors;\n    \n    import cucumber.api.Transpose;\n    import cucumber.api.java.en.Given;\n    import cucumber.api.java.en.Then;\n    import cucumber.api.java.en.When;\n    \n    public class SomeSteps\n    {\n        private TaskPage taskPage = new TaskPage();\n        private AddTaskPage addTaskPage = new AddTaskPage();\n        private EditTaskPage editTaskPage = new EditTaskPage();\n    \n        @Given(\"^I am on the task list$\")\n        public void iAmOnTheTaskList()\n        {\n            taskPage.launch();\n        }\n    \n        @Then(\"^the list of tasks will be empty$\")\n        public void theListOfTasksWillBeEmpty()\n        {\n            taskPage.taskTable().assertEmpty();\n        }\n    \n        @When(\"^I choose to add these tasks$\")\n        public void iChooseToAddTheseTasks(List<TableRow> tasks)\n        {\n            for(TableRow task : tasks)\n                {\n                    taskPage.addButton().click();\n                    addTaskPage.set(task);\n                    addTaskPage.saveButton().click();\n                }\n        }\n    \n        @Then(\"^I will see this on the list of tasks$\")\n        public void iWillSeeThisOnTheListOfTasks(List<TableRow> tasks)\n        {\n            taskPage.taskTable().matches(tasks);\n        }\n    \n        @When(\"^I will select these tasks$\")\n        public void iWillSelectTheseTasks(List<TableRow> tasks)\n        {\n            taskPage.taskTable().matches(tasks.stream().map(t -> t.except(\"select\")).collect(Collectors.toList()));\n            taskPage.taskTable().set(tasks.stream().map(t -> t.except(\"name\", \"priority\")).collect(Collectors.toList()));\n        }\n    \n        @When(\"^I choose to delete the selected tasks$\")\n        public void iChooseToDeleteTheSelectedTasks()\n        {\n            taskPage.deleteButton().click();\n        }\n    \n        @Then(\"^the delete button is disabled$\")\n        public void theDeleteButtonIsDisabled()\n        {\n            taskPage.deleteButton().assertDisabled();\n        }\n\n        @When(\"^I edit the '([^']*)' task$\")\n        public void iEditTheBuyTask(String name)\n        {\n            taskPage.taskTable().findFirst(row -> row.get(\"name\").equals(name)).getWidget(4).click();\n        }\n    \n        @Then(\"^the edit form will contain$\")\n        public void theEditFormWillContain(@Transpose List<TableRow> task)\n        {\n            editTaskPage.matches(task.get(0));\n        }\n    \n        @When(\"^I save these changes$\")\n        public void iSaveTheseChanges(@Transpose List<TableRow> task)\n        {\n            editTaskPage.set(task.get(0));\n            editTaskPage.saveButton().click();\n        }\n    }\n\n&lt; [Deleting tasks](/#/tutorial/tutorial-6) | ^ [Tutorial](/#/tutorial/tutorial) | [Custom components](/#/tutorial/tutorial-8) &gt;\n",
    "iso8601Date": "2018-11-09T07:59:00+00:00",
    "basename": "tutorial-7"
  }
,
  "tutorial-8": {
    "title": "Custom components",
    "author": "David Griffiths",
    "image": "images/Relish.png",
    "date": "2018-11-09 07:59",
    "tags": [
      "Tutorial"
    ],
    "preview": "Web applications often share custom components between pages, and so …",
    "content": "\n\nWeb applications often share custom components between pages, and so it makes sense to create matching test components that can also be shared.\n\nFor example, consider the pages for adding and editing tasks:\n\n![img](images/add-with-priority.png)\n\n![img](images/edit-task.png)\n\nThe fields and the save button are exactly the same. The code that each of them runs may well be very different, but if the fields can be found in the same way (which would be the case if the implementation uses a custom component for the form) then we should be able to create our own custom component for interacting with the form:\n\n    package com.example.components;\n    \n    import org.openqa.selenium.By;\n    \n    import uk.co.blackpepper.relish.core.Component;\n    import uk.co.blackpepper.relish.selenide.DropDown;\n    import uk.co.blackpepper.relish.selenide.InputText;\n    import uk.co.blackpepper.relish.selenide.RadioButtons;\n    import uk.co.blackpepper.relish.selenide.SelenideWidget;\n    \n    public class TaskForm extends SelenideWidget {\n        public TaskForm(Component parent) {\n            super(By.cssSelector(\"body\"), parent);\n        }\n    \n        public InputText name() {\n            return new InputText(By.id(\"name\"), this);\n        }\n    \n        public DropDown priority() {\n            return new DropDown(By.id(\"priority\"), this);\n        }\n    \n        public SelenideWidget saveButton() {\n            return new SelenideWidget(By.className(\"saveButton\"), this);\n        }\n    }\n\nOur custom component extends `SelenideWidget`, and accepts a *parent* component in the constructor; this will be the Relish component that contains. In our case, this will be the `EditTaskPage` or the `AddTakePage`. If the form is always contained inside some element within the web page, we could has also included a selector for this in the constructor. Instead, we've kept it simple and told the super-class the form can be found somewhere within the `<body>` of the page.\n\nNow we've created our form component, we can greatly simplify the `AddTaskPage` and `EditTaskPage` classes:\n\n    package com.example.components;\n    \n    import uk.co.blackpepper.relish.selenide.Page;\n    \n    public class AddTaskPage extends Page {\n        public AddTaskPage() {\n            super(\"/add.html\");\n        }\n    \n        public TaskForm form() {\n            return new TaskForm(this);\n        }\n    }\n\n<p/>\n\n    package com.example.components;\n    \n    import uk.co.blackpepper.relish.selenide.Page;\n    \n    public class EditTaskPage extends Page {\n        public EditTaskPage() {\n            super(\"/edit.html\");\n        }\n    \n        public TaskForm form() {\n            return new TaskForm(this);\n        }\n    }\n\nBecause we've changed the pages, we will need to make changes in `SomeSteps.java`, so that a call like:\n\n    editTaskPage.set(task.get(0));\n\nwill become:\n\n    editTaskPage.form().set(task.get(0));\n\nSo that `SomeSteps.java` will now be:\n\n    package com.example.steps;\n    \n    import com.example.components.AddTaskPage;\n    import com.example.components.EditTaskPage;\n    import com.example.components.TaskPage;\n    \n    import uk.co.blackpepper.relish.core.TableRow;\n    \n    import java.util.List;\n    import java.util.stream.Collectors;\n    \n    import cucumber.api.Transpose;\n    import cucumber.api.java.en.Given;\n    import cucumber.api.java.en.Then;\n    import cucumber.api.java.en.When;\n    \n    public class SomeSteps\n    {\n        private TaskPage taskPage = new TaskPage();\n        private AddTaskPage addTaskPage = new AddTaskPage();\n        private EditTaskPage editTaskPage = new EditTaskPage();\n    \n        @Given(\"^I am on the task list$\")\n        public void iAmOnTheTaskList()\n        {\n            taskPage.launch();\n        }\n    \n        @Then(\"^the list of tasks will be empty$\")\n        public void theListOfTasksWillBeEmpty()\n        {\n            taskPage.taskTable().assertEmpty();\n        }\n    \n        @When(\"^I choose to add these tasks$\")\n        public void iChooseToAddTheseTasks(List<TableRow> tasks)\n        {\n            for(TableRow task : tasks)\n                {\n                    taskPage.addButton().click();\n                    addTaskPage.form().set(task);\n                    addTaskPage.form().saveButton().click();\n                }\n        }\n    \n        @Then(\"^I will see this on the list of tasks$\")\n        public void iWillSeeThisOnTheListOfTasks(List<TableRow> tasks)\n        {\n            taskPage.taskTable().matches(tasks);\n        }\n    \n        @When(\"^I will select these tasks$\")\n        public void iWillSelectTheseTasks(List<TableRow> tasks)\n        {\n            taskPage.taskTable().matches(tasks.stream().map(t -> t.except(\"select\")).collect(Collectors.toList()));\n            taskPage.taskTable().set(tasks.stream().map(t -> t.except(\"name\", \"priority\")).collect(Collectors.toList()));\n        }\n    \n        @When(\"^I choose to delete the selected tasks$\")\n        public void iChooseToDeleteTheSelectedTasks()\n        {\n            taskPage.deleteButton().click();\n        }\n    \n        @Then(\"^the delete button is disabled$\")\n        public void theDeleteButtonIsDisabled()\n        {\n            taskPage.deleteButton().assertDisabled();\n        }\n\n        @When(\"^I edit the '([^']*)' task$\")\n        public void iEditTheBuyTask(String name)\n        {\n            taskPage.taskTable().findFirst(row -> row.get(\"name\").equals(name)).getWidget(4).click();\n        }\n    \n        @Then(\"^the edit form will contain$\")\n        public void theEditFormWillContain(@Transpose List<TableRow> task)\n        {\n            editTaskPage.form().matches(task.get(0));\n        }\n    \n        @When(\"^I save these changes$\")\n        public void iSaveTheseChanges(@Transpose List<TableRow> task)\n        {\n            editTaskPage.form().set(task.get(0));\n            editTaskPage.form().saveButton().click();\n        }\n    }\n\nWhich means that if we now get another requirement, such as a new set of radio-buttons for *Task status*:\n\n![img](images/with-status.png)\n\nWe just have to add a single method to the `TaskForm` component called `status()` which returns a Relish `RadioButtons` component:\n\n    package com.example.components;\n    \n    import org.openqa.selenium.By;\n    \n    import uk.co.blackpepper.relish.core.Component;\n    import uk.co.blackpepper.relish.selenide.DropDown;\n    import uk.co.blackpepper.relish.selenide.InputText;\n    import uk.co.blackpepper.relish.selenide.RadioButtons;\n    import uk.co.blackpepper.relish.selenide.SelenideWidget;\n    \n    public class TaskForm extends SelenideWidget {\n        public TaskForm(Component parent) {\n            super(By.cssSelector(\"body\"), parent);\n        }\n    \n        public InputText name() {\n            return new InputText(By.id(\"name\"), this);\n        }\n    \n        public DropDown priority() {\n            return new DropDown(By.id(\"priority\"), this);\n        }\n    \n        public RadioButtons status() {\n            return new RadioButtons(By.name(\"status\"), this);\n        }\n    \n        public SelenideWidget saveButton() {\n            return new SelenideWidget(By.className(\"saveButton\"), this);\n        }\n    }\n\nAnd we can then update our feature file to add `status` values to be set and checked throughout:\n\n    Feature: A list of tasks can be managed by the application\n      As a user\n      I want to be able to create, read, update and delete tasks\n      So that I can manage my time\n    \n      Scenario: Initially the list of tasks is empty\n        Given I am on the task list\n        Then the list of tasks will be empty\n    \n      Scenario: I can add a task\n        Given I am on the task list\n        When I choose to add these tasks\n          | Name           | Priority | Status  |\n          | Buy some bread | H        | ready   |\n          | Buy some milk  | L        | waiting |\n        Then I will see this on the list of tasks\n          | Name           | Priority | Status  |\n          | Buy some bread | High     | Ready   |\n          | Buy some milk  | Low      | Waiting |\n    \n      Scenario: Can delete tasks\n        Given I am on the task list\n        Then the delete button is disabled\n        When I choose to add these tasks\n          | Name           | Priority |\n          | Buy some bread | H        |\n          | Buy some milk  | M        |\n          | Buy some water | L        |\n        And I will select these tasks\n          | Name           | Priority | Select |\n          | Buy some bread | High     | true   |\n          | Buy some milk  | Medium   | false  |\n          | Buy some water | Low      | true   |\n        And I choose to delete the selected tasks\n        Then I will see this on the list of tasks\n          | Name          | Priority | Select |\n          | Buy some milk | Medium   | false  |\n    \n      Scenario: Can edit a task\n        Given I am on the task list\n        When I choose to add these tasks\n          | Name           | Priority | Status  |\n          | Buy some bread | M        | ready   |\n          | Buy some milk  | L        | waiting |\n          | Buy some water | H        | pending |\n        And I change the 'Buy some milk' task to\n          | Name     | Buy some cream |\n          | Priority | M              |\n          | Status   | done           |\n        Then I will see this on the list of tasks\n          | Name           | Priority | Status  |\n          | Buy some bread | Medium   | Ready   |\n          | Buy some cream | Medium   | Done    |\n          | Buy some water | High     | Pending |\n\nAnd other than changing this in `SomeSteps.java`:\n\n    taskPage.taskTable().findFirst(row -> row.get(\"name\").equals(name)).getWidget(3).click();\n\nto\n\n    taskPage.taskTable().findFirst(row -> row.get(\"name\").equals(name)).getWidget(4).click();\n\nand this in `TaskPage.java`:\n\n    .withCellComponent(\"3\", (tdCell) -> new SelenideWidget(tdCell.$(\"button\"), this))\n\nto\n\n    .withCellComponent(\"4\", (tdCell) -> new SelenideWidget(tdCell.$(\"button\"), this))\n\n(so that we can still click the `Edit` button, which is now in the fourth column) we're done.\n\n![img](images/tutorial-run.gif)\n\n&lt; [Editing tasks](/#/tutorial/tutorial-7) | ^ [Tutorial](/#/tutorial/tutorial)\n",
    "iso8601Date": "2018-11-09T07:59:00+00:00",
    "basename": "tutorial-8"
  }
,
  "tutorial": {
    "title": "Relish Tutorial",
    "author": "David Griffiths",
    "image": "images/Relish.png",
    "date": "2018-11-09 07:59",
    "tags": [
      "Tutorial"
    ],
    "preview": "In this tutorial, we'll go through the steps required to create a …",
    "content": "\n\nIn this tutorial, we'll go through the steps required to create a Relish test suite for a simple task management application.\n\nYou can find the completed code in the [example-selenide](https://github.com/dogriffiths/relish/tree/master/examples/selenide/example-selenide) folder of the repo. When completed, the tutorial will run this sequence of automated tests:\n\n![img](../images/tutorial-run.gif)\n\n1. [Creating the project](/#/tutorial/tutorial-1)\nA walkthrough of creating the tasks tutorial testing project.\n\n2. [Create our tests](/#/tutorial/tutorial-2)\nCreate a feature file for a user story.\n\n3. [Relish components](/#/tutorial/tutorial-3)\nStarting our first proper scenario using Relish components.\n\n4. [Adding tasks](/#/tutorial/tutorial-4)\nSending data to a form and asserting the contents of a table.\n\n5. [Adding more fields](/#/tutorial/tutorial-5)\nHow Relish deals with the impact of changing the data model.\n\n6. [Deleting tasks](/#/tutorial/tutorial-6)\nAdding interactive components to a table, and working with `TableRow` objects.\n\n7. [Editing tasks](/#/tutorial/tutorial-7)\nHandling table columns without headings and filtering rows.\n\n7. [Custom components](/#/tutorial/tutorial-8)\nIf you re-use components in your, you should consider re-using components in your tests.\n",
    "iso8601Date": "2018-11-09T07:59:00+00:00",
    "basename": "tutorial"
  }
}
